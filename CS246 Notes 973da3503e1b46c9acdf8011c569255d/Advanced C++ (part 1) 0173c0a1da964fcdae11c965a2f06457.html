<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Advanced C++ (part 1)</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-opaquegray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="0173c0a1-da96-4fcd-ae11-c965a2f06457" class="page sans"><header><h1 class="page-title">Advanced C++ (part 1)</h1></header><div class="page-body"><h1 id="0ef1f141-5c6e-4e25-81d4-2ed7799bec27" class="">Exception Safety</h1><p id="67b37183-c8cd-4940-b2fe-4d96fccb73e2" class="">When we create an object, the object is either stack allocated or heap allocated.</p><ul id="3957fb4e-4e34-4d7f-9075-5690f7a5ea15" class="bulleted-list"><li style="list-style-type:disc">For stack-allocated objects:
Destructor runs automatically when object is out of scope.</li></ul><ul id="8d24463e-5cf2-4a82-8f07-af23e22e42dc" class="bulleted-list"><li style="list-style-type:disc">For heap-allocated objects:<p id="30ad0ec3-7cff-44b5-bfb0-209068a23dcc" class="">We need to manually delete the pointer pointing to the heap allocated object to call the destructor.</p></li></ul><ul id="bf2d0518-5928-4834-a0f6-9f525db8d3bc" class="bulleted-list"><li style="list-style-type:disc">Heap allocated objects will be deleted whenever we don’t need them anymore, often happens right before function or program finishes running.</li></ul><p id="5303e089-3aa5-45e4-a70a-e802cd23cf46" class="">
</p><p id="bb05ae64-5200-438c-b1e4-e9cba12c8e77" class=""><strong>Question:</strong> What if exceptions are involved?</p><ul id="a4bc2c64-4095-4b13-bcb1-9310469afb08" class="bulleted-list"><li style="list-style-type:disc">If some function throws an exception and does not catch the exception, the current stack frame is unwound and program will keep unwinding stack frames until it finds one or program is aborted.</li></ul><ul id="be2fc096-97b0-4c12-ad11-2a5e886ebb49" class="bulleted-list"><li style="list-style-type:disc">If such function throws the exception in middle of execution, then the rest of lines of code will never be executed.</li></ul><p id="f62ea212-d99c-44fe-bf81-a4369487587c" class="">
</p><p id="0611e35f-2b89-4c19-ba75-697588555d57" class="">Example: consider the following code:</p><figure id="0fd3b05b-bec3-4993-a0fa-cbe097f67e13" class="image"><a href="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled.png"><img style="width:576px" src="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled.png"/></a></figure><p id="91f124d4-0e85-47dc-b854-46601f34ec4e" class="">Assume we don’t know the implementation for function foo() right now. Regardless of <em>foo()</em> throwing an exception, we want our program runs correctly, so we add an exception handler in main function.</p><p id="a29bafd4-9c85-4a99-a696-cb00674a7885" class="">
</p><p id="8ae42a0a-6326-4099-8240-fa2a731a0322" class=""><strong>Case 1: Function foo() does  not throw an exception:</strong></p><figure id="5f8661ab-dd46-47a6-b00a-19f1b5555c31" class="image"><a href="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%201.png"><img style="width:469px" src="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%201.png"/></a></figure><p id="4526137d-97d6-4076-8357-f47dd4efc6d0" class="">Result:</p><figure id="64b8d29b-eb89-4a71-a2b9-31b368655c86" class="image"><a href="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%202.png"><img style="width:576px" src="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%202.png"/></a><figcaption>No memory leak occurs</figcaption></figure><p id="66e03be1-3941-4471-8aa8-82cf3b8d8479" class="">
</p><p id="047dde30-ca60-423b-a9de-9b88ca7cbe63" class=""><strong>Case 2: foo() throws an exception:</strong></p><figure id="fb4fc61a-b1f3-4018-a526-f41ac91aaf10" class="image"><a href="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%203.png"><img style="width:336px" src="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%203.png"/></a></figure><p id="afc5633f-5e0c-482b-ad76-2b2cd7399708" class="">In this case, doSomething() did not catch the exception. Stack frame is unwound and the last line will never be executed.</p><figure id="94a8f021-ea3f-4813-b08b-9cc6b0ad1062" class="image"><a href="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%204.png"><img style="width:528px" src="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%204.png"/></a></figure><p id="00d8b510-6b5f-46b0-94b1-692252edcb32" class="">Result: Memory leak occurs</p><figure id="6e2f18d6-87a9-43cb-a504-0b373ddfab21" class="image"><a href="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%205.png"><img style="width:528px" src="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%205.png"/></a><figcaption>Memory leak occurs</figcaption></figure><p id="27f6ffd4-95a2-43ab-b0e3-f2272f46c3bf" class="">How do we fix this?</p><p id="827612d3-fa1c-42a8-b8ea-1aedbd3bcb87" class=""><strong>Solution:</strong></p><figure id="c7f5ff06-4a58-4143-8e91-0d6c25f69e32" class="image"><a href="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%206.png"><img style="width:384px" src="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%206.png"/></a></figure><ul id="8535a78b-6b67-4597-90dd-5bfed784d9b0" class="bulleted-list"><li style="list-style-type:disc">The simplest way to fix</li></ul><ul id="3f2d9701-82ef-4c16-aed3-b0b0daefb24e" class="bulleted-list"><li style="list-style-type:disc">Add exception handler for <em>doSomething()</em></li></ul><ul id="d245dcda-4ac7-4c04-aca0-6b7c7ac6586b" class="bulleted-list"><li style="list-style-type:disc">Re-throw the error to avoid memory error</li></ul><p id="de8b9b19-c32f-4c89-9b7a-c3cd4621047f" class="">
</p><p id="bbc5a566-9a4c-4b83-8c27-a94488c61aa1" class="">Result:</p><figure id="a494ec3c-c7b1-4a10-bb3d-e82e121bbf4f" class="image"><a href="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%207.png"><img style="width:576px" src="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%207.png"/></a><figcaption>No more memory leaks</figcaption></figure><p id="839aadcb-ee99-427b-85b8-ef16a617aec5" class="">
</p><p id="530cc0e3-396d-4c09-b2a6-44d9aaea90c3" class=""><em><strong>Idea: </strong></em><em>How can we let C++ automatically de-allocate memories for us?</em></p><p id="830e6adf-ab21-435b-a849-96256c51d0fc" class="">Consider the following code:</p><figure id="abeb4573-9696-469a-ad8d-4f7b19e2d372" class="image"><a href="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%208.png"><img style="width:432px" src="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%208.png"/></a></figure><p id="f401c7f6-4627-47ca-966b-760dc41af12a" class="">By using the wrapper strategy, we write the deallocation command in the class destructor. In this way, when the stack-allocated object is out of scope, CPU will automatically call the object destructor and therefore, delete the heap-allocated memory for us. (Smart pointers)</p><p id="5ff878a7-302e-440c-9603-4b653b634fec" class="">
</p><h1 id="0bb00778-7468-412d-a94c-cfb45f56c411" class="">Smart Pointers</h1><p id="9998c0c7-9d8a-4477-b97f-a3e059ad50a7" class=""><strong>Recall </strong><strong><em>stack allocated</em></strong><strong> objects:</strong></p><ul id="7dd3c314-0d23-41a1-ae4e-775d57ef6e09" class="bulleted-list"><li style="list-style-type:disc">object is de-allocated once the corresponding stack frame is unwound (out of scope).</li></ul><ul id="d551c468-ee17-4eb3-abfd-9eb1844e0e0d" class="bulleted-list"><li style="list-style-type:disc">guaranteed to be de-allocated no matter what happens.</li></ul><ul id="5003c424-047e-414c-8e1c-a7b3eb835ceb" class="bulleted-list"><li style="list-style-type:disc">no memory leaks.</li></ul><p id="780b2ed5-4e86-4dcc-a4f1-a51e55b44724" class="">
</p><p id="9d4a8f8a-6e4d-4288-9581-ab94f4610e6a" class=""><strong>Disadvantages:</strong></p><ul id="a6f6e71b-a300-421f-bc9b-855333cfd71c" class="bulleted-list"><li style="list-style-type:disc">lifetime is fixed and short (depends on the scope that defines it).</li></ul><ul id="2b9eb83b-e6fd-4678-bcf9-e5c94de25d47" class="bulleted-list"><li style="list-style-type:disc">we have no control over extending the lifetime of an object.</li></ul><ul id="1766b2fb-30c9-4091-a9d5-8cd2cfea50b8" class="bulleted-list"><li style="list-style-type:disc">as a result, it is better to use heap memory to let objects live “longer”.</li></ul><ul id="651ba45f-3a89-4ccf-a8a5-64459165bbc6" class="bulleted-list"><li style="list-style-type:disc">difficult to manage (control flows, exceptions).</li></ul><ul id="971556c8-50cb-4043-a113-4c8643ae4a26" class="bulleted-list"><li style="list-style-type:disc">Potential risks on memory leak.</li></ul><p id="d4dcd28d-b483-451b-8046-666149842b71" class="">
</p><p id="f6e1cb67-9b8f-4650-9b5f-cc1a93d14090" class=""><strong>Solution:</strong></p><ul id="488f3270-1213-4238-a0d1-cd1857144eae" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-red">wrapper class</mark> for <mark class="highlight-red">pointers</mark> pointing to heap memory</li></ul><ul id="561f3766-ccef-470c-8948-01fd3afcec6f" class="bulleted-list"><li style="list-style-type:disc">wrapper class object is stack allocated, if such object is out of scope, wrapped pointer is deleted.</li></ul><p id="83db5ab8-f28a-4af1-9a03-8afa2024e910" class="">
</p><p id="38c19774-b394-4f2b-bb35-9ab02cbea4d5" class="">C++ STL provides two template wrapper Class for pointers:</p><p id="ad102792-656b-4642-b579-45ee9248ab5a" class="">Library to include: <code>#include &lt;memory&gt;</code></p><p id="f187939c-5167-494d-8d29-8fb95491952f" class="">This allows us to use these template wrapper classes.</p><p id="2ca9d2ee-0466-4f2b-a9e2-9cea918d2bec" class="">
<strong>Type 1: unique pointers: </strong><code>std::unique_ptr&lt;T&gt;</code></p><p id="dad1cccd-02a3-4d1e-8e9a-601f7ee7a336" class="">It owns and manages another object through a pointer and disposes of that object when unique pointer is out of scope.</p><p id="89ef7c82-2f64-4949-b283-8677fc877247" class="">
</p><p id="fc9f866c-858d-4e37-829f-95d000c4021a" class=""><strong>Type 2: shared pointers: </strong><code>std::shared_ptr&lt;T&gt;</code></p><ul id="ff024130-08e0-4e45-a254-5beda1411b3e" class="bulleted-list"><li style="list-style-type:disc">retains shared ownership of an object through a pointer.</li></ul><ul id="e9c49746-20b0-4c07-9e01-c4066fe6723f" class="bulleted-list"><li style="list-style-type:disc">several shared pointer objects may own the same object.</li></ul><p id="4d317ca7-0398-4795-a195-dc67608fccc1" class="">
</p><p id="a705431f-f513-486b-b569-ec69cd4a37ca" class="">
</p><p id="37d79ce7-f3a6-4fd0-9a27-6a0f5c26e50a" class="">
</p><h2 id="f4ba460c-360a-499d-bece-8ac8e8574ba6" class="">Unique pointers:</h2><p id="2ac98389-9c89-48e5-a902-7f25705488f0" class="">Example: consider the following code:</p><figure id="dd2cd1ec-702d-45a2-b4b6-8ddfbf65d9c3" class="image"><a href="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%209.png"><img style="width:432px" src="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%209.png"/></a></figure><p id="9e8fc4bd-5ef2-40a0-8f1d-ff50dac36dad" class="">List object is heap allocated. If we don’t manually delete the pointer, memory leaks.</p><p id="08bb4e7b-c022-4375-b3ba-b074302c168b" class="">How do we solve this issue using unique pointers?</p><p id="e8b6bec8-2525-4d95-941d-2865cb621370" class="">
</p><p id="bc2b0ca5-3109-4565-9672-884702f07f02" class="">Two ways of creating unique pointer objects:</p><p id="7552879c-5f84-4f8d-9fba-56af03135d50" class=""><em><strong>Method 1: traditional way: pass in a pointer pointing to heap-allocated object we created</strong></em></p><p id="8ab25659-56f9-4e0d-8425-0b4a5b0f17f0" class=""><code>std::unique_ptr&lt;List&gt; l1 = std::unique_ptr&lt;List&gt;( new List{1, new List{2} );</code></p><p id="fcd9f036-b691-45d3-9457-4c28166505a1" class="">
</p><p id="9d68460e-bdc4-4591-a190-dbc0699fc9a3" class=""><em><strong>Method 2: easier approach: pass in parameters of the object constructor</strong></em></p><p id="45cf89f2-8e54-41b6-97f1-80797b5b7845" class=""><code>std::unique_ptr&lt;List&gt; l1 = make_unique&lt;List&gt;( 1, new List{2} );</code></p><p id="6f0d4fd7-bbf1-4771-8d04-4717c75916ab" class="">
</p><p id="20018ebb-7fa7-4db2-8ba7-92022ec94eea" class="">Example: exception involved</p><figure id="d9a276c6-cf75-4dbd-811e-cfa2656f9efe" class="image"><a href="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2010.png"><img style="width:480px" src="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2010.png"/></a></figure><p id="4954fe9c-e2d9-451b-9040-145c09a70b63" class="">Result:</p><figure id="ea40f25b-4d7d-40e1-8a82-4f58e9a6b674" class="image"><a href="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2011.png"><img style="width:528px" src="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2011.png"/></a></figure><ul id="4acab80a-f039-43a5-af80-e2b8f2359286" class="bulleted-list"><li style="list-style-type:disc"><em>p</em> is destroyed if the corresponding stack frame is unwound.</li></ul><ul id="79e6f280-be56-40d2-8afb-a5995af8c06f" class="bulleted-list"><li style="list-style-type:disc">since <em>p</em> owns the pointer to <code>Posn</code> object, then <code>Posn</code> object is destroyed if <em>p</em> is destroyed (composition).</li></ul><ul id="9c3b73f5-2da2-4e7e-b9c5-dc4cc09e74b1" class="bulleted-list"><li style="list-style-type:disc">guaranteed <mark class="highlight-red">no memory leak </mark>no matter what happens.</li></ul><p id="f7a249a3-2ee8-4188-9892-4ef2ba294955" class="">
</p><h3 id="c9a1a42f-1022-406c-b53e-3bae74e4c65a" class="">Unique pointers are “unique”:</h3><figure id="8d86e84e-2b79-491c-9136-cd21c4ee01ae" class="image"><a href="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2012.png"><img style="width:624px" src="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2012.png"/></a></figure><ul id="7d52dc5e-df0d-43c2-b209-ad27c37d359e" class="bulleted-list"><li style="list-style-type:disc">unique pointer means that this will be the <em><mark class="highlight-red">only</mark></em> pointer that that is taking care of the corresponding object.</li></ul><ul id="93b8da47-c63b-4c4b-a1c2-1aa4362d78a5" class="bulleted-list"><li style="list-style-type:disc"><em><mark class="highlight-red">one-to-one</mark></em> mapping only.</li></ul><ul id="ca18a5db-8f5f-4928-8abc-e59fc26306e8" class="bulleted-list"><li style="list-style-type:disc">we cannot have another unique pointer taking care of the same object.</li></ul><ul id="a7a25ebe-2e53-42ec-b207-9453fc5e6026" class="bulleted-list"><li style="list-style-type:disc">program won’t compile. Passing by value also won’t compile
<em><strong>Reason:</strong></em> passing by value is always making a <mark class="highlight-red">copy</mark> first, then pass to the function. And unique pointers cannot be copied.</li></ul><p id="5b28c365-44ba-4523-9fbd-454ff63a9ebc" class="">
</p><p id="fd87fd26-421c-4e5e-b5be-70382bc09d27" class="">Solutions to this problem:</p><p id="b80cc85a-3f0d-4467-a5c6-c4ba0ed08c76" class=""><em><strong>Method 1: transfer ownership</strong></em></p><figure id="1a342d20-096c-42d9-b942-20adaa6814db" class="image"><a href="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2013.png"><img style="width:624px" src="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2013.png"/></a></figure><p id="4a4ad855-a5fa-4041-b933-3e5423eeb4c1" class="">
</p><p id="5070edb5-5b9e-4f24-96b6-926964d92776" class=""><strong>Command </strong><strong><code>std::move()</code></strong><strong>:</strong></p><ul id="32aa40dd-3019-4c71-a110-410eba829b59" class="bulleted-list"><li style="list-style-type:disc">Enforce to use move constructor and treat <span style="border-bottom:0.05em solid"><em>l1</em></span> as a rvalue object.</li></ul><ul id="6036fbfc-9516-42a5-888e-4dbae9c8f04a" class="bulleted-list"><li style="list-style-type:disc"><em>l1</em> defined in main function is destroyed after <code>std::move</code>.</li></ul><ul id="c83262e2-177e-4174-ad71-51adf0541d13" class="bulleted-list"><li style="list-style-type:disc"><em>l1</em> as parameter passed to <em>doSomething()</em> now has the ownership of the List object.</li></ul><p id="11c28638-81c5-47e8-9d1a-193eadb797bf" class="">
</p><p id="331b9d75-9e4d-49ed-a177-9e777556b016" class="">Result:</p><figure id="a475bbe4-328a-482d-9966-575315feca16" class="image"><a href="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2014.png"><img style="width:576px" src="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2014.png"/></a></figure><p id="a13fbdf8-2558-4a73-b904-ea2118e59336" class="">
</p><p id="4676ddab-6e31-405b-a03c-97305d1d1bb8" class=""><em><strong>Method 2: pass by reference</strong></em></p><figure id="ea1f5d04-15b2-4ee2-9e7a-36be87d19b05" class="image"><a href="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2015.png"><img style="width:624px" src="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2015.png"/></a></figure><p id="1c8aeca6-680a-4407-aa47-34832cc61579" class="">Recall the definition of reference:</p><ul id="356fd036-4085-4d7f-840c-8591505280ca" class="bulleted-list"><li style="list-style-type:disc">the second label of the corresponding memory address.</li></ul><ul id="5db6ceb1-c8a1-47c2-972d-ee6c9978f2f6" class="bulleted-list"><li style="list-style-type:disc">same unique pointer is taking care of the object.</li></ul><ul id="5a69eff8-39ba-422d-8b1e-702a2af13ceb" class="bulleted-list"><li style="list-style-type:disc">compiles and run correctly.</li></ul><p id="590e2c8b-8cd9-412f-822f-bba2eea4599e" class="">
</p><p id="bc1e2a78-041d-4c48-8d97-c04ffbe4184e" class=""><em><strong>Method 3: </strong></em><em><strong><code>get()</code></strong></em><em><strong> method</strong></em></p><figure id="f70649b8-5bbd-455b-8166-d35297b3cdcf" class="image"><a href="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2016.png"><img style="width:624px" src="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2016.png"/></a></figure><p id="e467c94b-c778-47c2-9216-5579f373b519" class="">
</p><ul id="1d391e6d-d8ae-4d54-9f8c-07f90889b158" class="bulleted-list"><li style="list-style-type:disc">If <em>doSomething()</em> only takes a raw pointer, we need to use <code>get()</code> to retrieve the underlying pointer wrapped by unique pointer.</li></ul><ul id="1612c8de-b786-4003-8ee7-c468d1d34f54" class="bulleted-list"><li style="list-style-type:disc">Still considered owned by the unique pointer.</li></ul><p id="b0318ec5-5215-4e06-b837-ed9652abccf2" class="">
</p><p id="6939d07b-3e76-4cfa-8d3c-96aba6313d90" class="">Unique pointers seem to have many restrictions: it cannot pass by value and cannot have multiple pointers taking care of the same object. Is there another more flexible approach?</p><p id="b2af4c5d-488e-468c-aebf-2aaee562a799" class="">YES!</p><p id="18e25d13-fd60-4e32-b5b4-01dceea3a036" class="">
</p><p id="cc54d580-2f8c-405d-93b3-d2558cb100eb" class="">
</p><h2 id="4e8b4a58-fd9b-43c7-9ae9-37f2c3387c51" class="">Shared pointers:</h2><ul id="b271215f-1643-4c58-a6e3-66f5248ac6fe" class="bulleted-list"><li style="list-style-type:disc">Several shared pointers can take care of the same object.</li></ul><ul id="7fade5c3-25c4-4d47-a022-5b88b1accab9" class="bulleted-list"><li style="list-style-type:disc">Can pass by value (allows copying).</li></ul><p id="a9ee4e7e-211b-420c-9d04-954bd1fc1b2a" class="">
</p><p id="50223a0f-7d5c-403c-8445-717301b35bba" class=""><em><strong>Question:</strong></em></p><p id="cc89b122-374e-4724-9154-0f3cda8d2aae" class="">If several shared pointers can take care of the same object, then when the object will be destroyed?</p><p id="36f7fe95-b40a-48d5-88d2-20fdd274f312" class=""><em><strong>Answer:</strong></em></p><p id="87f09e24-df53-4b84-8aee-14401aebf35f" class="">When the last remaining shared pointer object is out of scope or when the last remaining shared pointer is assigned to another object.</p><p id="82bd96c4-bd88-403d-a8c9-a18e8ce6691b" class="">
</p><p id="03275f0d-c691-4adc-b905-247d5ba36afe" class=""><em><strong>Benefits:</strong></em></p><ul id="7aa14efb-f75e-4bdf-acb3-a8742574bb7b" class="bulleted-list"><li style="list-style-type:disc">No need to worry about counting how many shared pointers are taking care of the same object.</li></ul><ul id="576ad6a9-e821-43b3-b6d0-013ed139c3f2" class="bulleted-list"><li style="list-style-type:disc">Template class <code>shared_ptr</code> itself handles the counting.</li></ul><p id="5a914a78-8137-4ee3-a761-8e58392420d6" class="">
</p><p id="868cf9df-11c8-494e-91f1-700348d5a86b" class="">Example:</p><figure id="fb4c030d-95df-4ca0-ad09-b81f7d058489" class="image"><a href="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2017.png"><img style="width:624px" src="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2017.png"/></a></figure><p id="e1b37f37-b642-4ef3-a267-92444ab7cd2b" class="">
</p><p id="63c8d7c6-c196-43f7-838e-4a19461c6aab" class="">However, there are some potential risks:</p><p id="a3155782-149e-40ce-bc12-facfa25ed3a1" class="">If cycles exist, no object is destroyed and memory leaks eventually.</p><p id="8ecba19e-61a8-4883-8583-94553b742925" class="">
</p><p id="f2e906e1-45af-4b2b-9cc4-388c7062b1a2" class="">Example:</p><figure id="ae429ab2-05f5-48b2-979d-f72973d512c6" class="image"><a href="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2018.png"><img style="width:528px" src="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2018.png"/></a></figure><p id="c5147714-e1a5-4b9e-870a-b8c47098aca1" class="">Result:</p><figure id="2c3fb845-5ade-4603-a95a-6f05b0b34726" class="image"><a href="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2019.png"><img style="width:528px" src="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2019.png"/></a></figure><p id="b29db9e5-1657-45ce-8bcd-ab08eea1b6c0" class="">
</p><p id="6cd7c80d-93bf-4ddd-8804-30c72b3ac5e6" class="">
</p><h1 id="548b88df-3d87-405c-b4f3-1867eb9bb88c" class="">Resource Acquisition Is Initialization (RAII)</h1><ul id="73aaf033-b0c3-4757-a13c-98d512c798bc" class="bulleted-list"><li style="list-style-type:disc">Resource Acquisition Is Initialization (RAII)</li></ul><ul id="ad76872d-290b-4943-b358-0f464dfc6f63" class="bulleted-list"><li style="list-style-type:disc">Resources that must be explicitly cleaned up, such as heap-allocated objects, are bound to resources which are cleaned up automatically.</li></ul><ul id="07d9a81a-3485-431e-b2d2-1f6eb4d9e9de" class="bulleted-list"><li style="list-style-type:disc">smart pointers are examples of RAII.</li></ul><p id="f74ca68c-3ae3-451b-974c-54be097f9e3a" class="">
</p><p id="3e835c6e-60c5-40d8-9f36-abac21a0ebd1" class="">Examples:</p><ul id="bc02d06a-3604-4355-b66c-2537c2eca61d" class="bulleted-list"><li style="list-style-type:disc"><code>std::vector&lt;Posn&gt;</code> has RAII, if vector is out of scope, all <code>Posn</code> objects are destroyed.</li></ul><ul id="5179fb38-61fb-4e02-95af-e41f198b75f1" class="bulleted-list"><li style="list-style-type:disc"><code>std::vector&lt;Posn*&gt;</code> does <mark class="highlight-red">not</mark> have RAII, if vector is out of scope, all pointers are cleared, but not deleted, memory leaks.</li></ul><ul id="dcc31336-66db-48a6-bec7-3a3ca748d64e" class="bulleted-list"><li style="list-style-type:disc"><code>std::vector&lt;std::unique_ptr&lt;Posn&gt;&gt;</code> has RAII, but hard to use, not recommended. </li></ul><ul id="8e642d21-601c-4302-aabd-e9e5eb129fd5" class="bulleted-list"><li style="list-style-type:disc"><code>std::vector&lt;std::shared_ptr&lt;Posn&gt;&gt;</code> has RAII, easy to use, recommended.</li></ul><p id="c509e4df-af8f-480c-b96d-ecb5679fe408" class="">
</p><h2 id="3baed6a5-fcb6-470f-8a68-6b0a0a9a1833" class="">Exception Safety:</h2><p id="22b7c8cc-4102-4711-9035-a00c1627b3e7" class="">Guarantees of RAII: Resources will be freed eventually no matter what happens.</p><p id="49c65a08-09c6-4492-bfdf-7848e4ab72a2" class="">There are 3 levels of exception safety:</p><ul id="fae72409-c196-4bc6-9cd6-b0037e56c9b5" class="bulleted-list"><li style="list-style-type:disc">Basic guarantee</li></ul><ul id="9d71bea0-6318-451d-be3c-86ab4c411691" class="bulleted-list"><li style="list-style-type:disc">Strong guarantee</li></ul><ul id="631e8365-05e9-4bc7-ac4d-2ac911faab40" class="bulleted-list"><li style="list-style-type:disc">No-throw guarantee</li></ul><p id="4cacf97f-580d-44e8-a1e0-76b6959246c4" class="">
</p><h3 id="9781f056-9913-4d06-a605-88b67586e633" class="">Basic Guarantee:</h3><ul id="94467dfa-975d-488b-bc29-b0eced916e31" class="bulleted-list"><li style="list-style-type:disc">guarantees that no memory leak will occur.</li></ul><ul id="1650aa8d-65d7-49cb-be06-26f5e14bdb96" class="bulleted-list"><li style="list-style-type:disc">Program in valid, unspecified state.</li></ul><figure id="af1f9c97-43e7-46a2-9795-1303b03622b0" class="image"><a href="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2020.png"><img style="width:528px" src="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2020.png"/></a></figure><p id="d7e32ea5-fa3d-4c05-8bd0-9aa24b020861" class="">However,</p><ul id="e2517b73-5089-4f99-b394-52e734cb2c9b" class="bulleted-list"><li style="list-style-type:disc">No memory leak is not the only component that we as programmers are looking for.</li></ul><ul id="93e9fcd6-035b-4964-89fb-1adb7b01d3de" class="bulleted-list"><li style="list-style-type:disc">If exception arises, we often do not want to change the state of objects or resources.</li></ul><ul id="59a24202-2444-4aab-84b5-97b6312fa256" class="bulleted-list"><li style="list-style-type:disc">It’s better for us to pretend that such function is never called so that we can guarantee that the state of the object is not changed or class invariant is not broken.</li></ul><ul id="86970af1-5a6b-4489-92a8-4527ae75bf0f" class="bulleted-list"><li style="list-style-type:disc">Basic guarantee cannot achieve this.</li></ul><p id="2deada8a-0eb3-4d97-8477-16dd627f025a" class="">
</p><p id="6d35e52b-e714-4344-9fed-a9df7ffa5fe6" class="">For example:</p><p id="d22ee7d0-ff55-4095-919e-499380066efc" class="">Assume class <em>Line</em> has a private vector field initialized with size 5. Vector contains <code>Posn</code> objects which will form a line. You are asked to read from standard input, every two consecutive integers read from standard input forms a <code>Posn</code> object, and replace the contents in vector fields. If exception arises, it should act as if nothing has ever happened, vector should still have previous valid values.</p><p id="b820ef67-0b1a-4543-a2af-313459591f80" class="">
</p><p id="22adbf06-9322-4bd2-b221-732354967125" class="">Implementation:</p><figure id="807e4e44-df2a-433d-9fa8-bb32d5569626" class="image"><a href="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2021.png"><img style="width:528px" src="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2021.png"/></a></figure><figure id="cecfca57-97c7-49df-8c70-5e91d6b9eb0b" class="image"><a href="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2022.png"><img style="width:528px" src="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2022.png"/></a></figure><p id="ca3f3b98-d416-47c6-8013-b457b1860c34" class="">Client code:</p><figure id="85eb1bfc-e695-4d70-857a-52d26cc6b9c5" class="image"><a href="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2023.png"><img style="width:432px" src="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2023.png"/></a></figure><p id="74756bac-e86c-44e3-9c13-61876e288441" class="">
</p><figure id="ba1c8cdd-eda3-4f59-b0c9-2ff7e1c37c0e" class="image"><a href="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2024.png"><img style="width:576px" src="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2024.png"/></a><figcaption>When inputs are valid, the program runs correctly.</figcaption></figure><figure id="64cdc944-f7c6-4c55-a777-2d30d3aeed3b" class="image"><a href="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2025.png"><img style="width:576px" src="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2025.png"/></a><figcaption>When an exception is involved, the process breaks immediately and cannot go back to the previous state.</figcaption></figure><p id="9e8b0d39-d16f-4d9b-884a-4c5e1f2c24b1" class="">Therefore, with only basic guarantee, once the state of the object is changed, it can never go back.</p><p id="38629661-10b7-4a52-bca6-1a26319ade55" class="">So how do we fix it?</p><p id="40f4254f-a29e-4f62-89d3-aaeb9755f2ad" class="">
</p><p id="48311299-88e1-4ca5-bba4-2d039014646f" class="">Possible approach:</p><figure id="bee4e57f-f680-41f3-a7eb-8e03c85885de" class="image"><a href="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2026.png"><img style="width:576px" src="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2026.png"/></a></figure><figure id="5b93572b-ca89-4844-8cf8-2cc3992d63d1" class="image"><a href="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2027.png"><img style="width:576px" src="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2027.png"/></a></figure><p id="8c63d6d4-1a88-4094-bfd3-cc452c5ff113" class="">This seems correct: If exception arises, object retains its previous correct state.</p><p id="6dbd1512-df03-484e-861a-f5726fbf8f11" class="">What if line 48 (copy assignment operator) throws an exception?</p><p id="0f7566b5-5d93-47c5-852e-4f08b4819d91" class="">Copy assignment operator does not have <mark class="highlight-red">no-throw guarantee</mark> (mentioned later). Still not 100% safe.</p><p id="38179c7a-8a5a-47ce-b018-d9bae74fccc2" class="">
</p><p id="cbf4418d-9564-40f7-8949-8469f8bb57bf" class=""><strong>Better approach:</strong> Swap pointers (100% safe (no-throw guarantee) operation):</p><figure id="6ef3e8ab-9a19-4b3c-ae36-4c12bcd48d08" class="image"><a href="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2028.png"><img style="width:528px" src="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2028.png"/></a></figure><p id="674958ed-ef36-4bb3-ae0f-d691001efeec" class="">We can safely let object retain its most recent correct state. This is <em><strong><mark class="highlight-red">strong guarantee</mark></strong></em>.</p><p id="859c3f7d-fff0-459e-801e-d66eb68e6e14" class="">
</p><p id="fc21888d-399c-4ca8-8531-bf89e096bdf9" class="">
</p><h3 id="069666d5-2761-4d05-8321-38a4b4d6acb5" class="">Strong Guarantee:</h3><ul id="c1da3752-0a9e-4009-96ea-490bc6a55366" class="bulleted-list"><li style="list-style-type:disc">the state of program / object remains at the most recent correct state.</li></ul><ul id="4ef87105-22e5-465d-b890-d60f6864bb7e" class="bulleted-list"><li style="list-style-type:disc">act as if function (arising exception) is never called.</li></ul><p id="27ef66fe-7e36-4bda-8177-73b2a485f818" class="">
</p><p id="91aa7b3c-0046-4544-9d16-60589b878095" class=""><em><strong>Note:</strong></em></p><ul id="a8ec55b0-c06c-4ff1-b57f-e37e2bb92586" class="bulleted-list"><li style="list-style-type:disc">A function / method can offer <em><mark class="highlight-red">strong guarantee</mark></em> if and only if <strong><mark class="highlight-red">all</mark></strong> the functions / methods that it calls can offer <em>strong guarantee</em> or <em>no-throw guarantee</em>.</li></ul><ul id="95c4dbd7-3905-4de2-90e7-e8b8387edb40" class="bulleted-list"><li style="list-style-type:disc">Always add documentation if function offers strong guarantee.</li></ul><p id="1c38496d-b3cf-4092-a757-6be2ad83a829" class="">
</p><p id="2dd57001-3989-4a1f-8eac-4a8ed871a109" class="">
</p><h3 id="d9bf068f-2d49-4605-b99a-b285165eb720" class="">No-throw Guarantee:</h3><p id="352b5236-b68c-45df-9342-57aee3eb3ee0" class="">Function / method that will <mark class="highlight-red"><strong>NEVER</strong></mark> throw an exception.</p><p id="ae6a02e6-42fc-4485-bc45-aceb724d7e1a" class="">
</p><p id="53c84ee9-9119-475a-be93-9853e278089a" class="">In this course: default constructors and the Big Five does not throw exceptions. In real world, we do not make this assumptions on the Big Five.</p><p id="29459819-25f7-4930-ae36-00cc3681fffb" class="">
</p><p id="8a5ddb81-ab2a-4be6-9adb-dc14dd786b5a" class=""><strong>Keyword </strong><strong><code>noexcept</code></strong><strong>:</strong></p><p id="d31cef40-407a-4bdd-8a76-f4b3f3f0474e" class=""><code>noexcept</code> is telling the compiler that this function has a no-throw guarantee.</p><figure id="156d2a5c-31c9-4b6f-9082-3be214b98168" class="image"><a href="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2029.png"><img style="width:336px" src="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2029.png"/></a><figcaption>No-throw exception</figcaption></figure><p id="388a6cc8-a0e2-45f8-8dbc-537e7da953b2" class="">Different Syntax:</p><figure id="0b5c91fe-d342-45ef-920e-7a1fae52cc91" class="image"><a href="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2030.png"><img style="width:288px" src="Advanced%20C++%20(part%201)%200173c0a1da964fcdae11c965a2f06457/Untitled%2030.png"/></a></figure><p id="9674872b-2865-4f87-817a-f0bd07fc1098" class="">
</p><p id="974c701c-0ddf-41b3-a499-c449138243a5" class=""><code>noexcept</code>: no-throw guarantee
<code>noexcept(true):</code> no-throw guarantee
<code>noexcept(false)</code>: same as that <code>noexcept</code> is not used.</p><p id="7cf8bfb5-3be9-4b2e-8a51-47c34030d932" class="">(We usually do not use the last 2 syntax)</p><p id="b4d2fc1e-8642-4c37-acdf-9fffe4b59ddb" class="">
</p></div></article></body></html>